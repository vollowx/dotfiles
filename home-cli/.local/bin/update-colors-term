#!/usr/bin/env bash
set -euo pipefail

SEND_ALL=false
SEQ_FILE_DEFAULT="${HOME}/.cache/dotfiles/md3/sequences.txt"

usage() {
  cat <<'EOF'
Usage: send-sequences.sh [-a|--all] [SEQUENCES_FILE]

Apply OSC color sequences generated by matugen.

Options:
  -a, --all   Send to all user-owned terminals (/dev/pts/*).
  -h, --help  Show this help.

Without -a, sequences are applied only to the current terminal.
If SEQUENCES_FILE is omitted, default path is ~/.cache/dotfiles/md3/sequences.txt.
EOF
}

# Parse arguments
SEQ_FILE=""
while [[ $# -gt 0 ]]; do
  case "$1" in
  -a | --all)
    SEND_ALL=true
    shift
    ;;
  -h | --help)
    usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  -*)
    echo "Unknown option: $1" >&2
    usage
    exit 2
    ;;
  *)
    if [[ -z "$SEQ_FILE" ]]; then
      SEQ_FILE="$1"
      shift
    else
      echo "Too many arguments." >&2
      usage
      exit 2
    fi
    ;;
  esac
done

# Remaining args after '--' are not supported for now
if [[ $# -gt 0 ]]; then
  echo "Too many arguments." >&2
  usage
  exit 2
fi

SEQ_FILE="${SEQ_FILE:-$SEQ_FILE_DEFAULT}"

if [[ ! -r "$SEQ_FILE" ]]; then
  echo "Sequence file not found or not readable: $SEQ_FILE" >&2
  exit 1
fi

# Function that decodes and writes sequences to stdout
send_sequences() {
  # Read the file line-by-line, skip comments and blanks, decode backslash escapes.
  # Avoid adding extra newlines; the lines already end with BEL (\007).
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Strip possible CR in CRLF files
    line="${line%$'\r'}"
    # Skip comments/blank lines
    [[ -z "$line" || "${line:0:1}" == "#" ]] && continue
    # Decode backslash escapes and write raw bytes
    printf '%b' "$line"
  done <"$SEQ_FILE"
}

if [[ "$SEND_ALL" == true ]]; then
  # Apply to the current terminal (if stdout is a TTY)
  if [[ -t 1 ]]; then
    send_sequences
  fi

  TTY_GLOB="/dev/pts/[0-9]*"

  # Current TTY (if any) to avoid double-sending
  CUR_TTY=""
  if CUR_TTY="$(tty 2>/dev/null || true)"; then
    : # ok
  else
    CUR_TTY=""
  fi

  # Apply to all other writable TTYs owned by this user
  shopt -s nullglob
  for tty in $TTY_GLOB; do
    # Skip if not owned by us or not writable
    [[ -O "$tty" && -w "$tty" ]] || continue
    # Skip our current TTY (already applied above)
    [[ -n "$CUR_TTY" && "$tty" == "$CUR_TTY" ]] && continue
    # Some globs include non-number entries; already filtered for Linux, but be defensive
    if [[ "$tty" == "/dev/pts/ptmx" ]]; then
      continue
    fi
    # Send sequences; ignore failures on busy ttys
    send_sequences >"$tty" 2>/dev/null || true
  done
else
  # Only apply to the current terminal
  if [[ -t 1 ]]; then
    send_sequences
  else
    CUR_TTY="$(tty 2>/dev/null || true)"
    if [[ -n "$CUR_TTY" && -w "$CUR_TTY" ]]; then
      send_sequences >"$CUR_TTY"
    else
      echo "No controlling TTY detected; use -a to broadcast to all terminals." >&2
      exit 1
    fi
  fi
fi
